Index: ir2rgb_tools/new_align_ir2rgb.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># import cv2\n# import numpy as np\n# import os\n#\n# # ==== 可调参数 ====\n# TARGET_MATCHED_POINTS = 120\n# AREA_THRESH = 400000\n# FRAME_START = 1\n# FRAME_STEP = 1\n# NUM_TRIES = 300\n# SEARCH_DIRECTION = 'right'  # 'left' or 'right'\n#\n# # ==== 文件路径 ====\n# rgb_gt_path = r'D:\\JieRui2024\\datasets\\rgb_0061_gt.txt'\n# ir_gt_path = r'D:\\JieRui2024\\datasets\\inf_0061_gt.txt'\n# mask_flag_path = r'D:\\JieRui2024\\datasets\\mask_0061gt.txt'\n# save_path = r'D:\\JieRui2024\\ir2rgb_tools\\0061_affine_matrix.npy'\n#\n#\n# log_path = '0275_matched_points_log.txt'\n#\n# rgb_img_template = r'D:\\5-16data\\jierui24_final_RGB\\train\\0275\\image\\{:06d}.jpg'\n# ir_img_template = r'D:\\5-16data\\jierui24_final_INF\\train\\0275\\image\\{:06d}.jpg'\n#\n#\n# def load_mask_flags(mask_path):\n#     \"\"\"\n#     所有出现在 mask.txt 文件中的帧都被认为是被遮挡帧\n#     \"\"\"\n#     masked = set()\n#     with open(mask_path, 'r') as f:\n#         for line in f:\n#             parts = line.strip().split(',')\n#             if len(parts) >= 1:\n#                 frame_id = int(parts[0])\n#                 masked.add(frame_id)\n#     return masked\n#\n#\n# def load_gt_dict(filepath):\n#     \"\"\"\n#     加载 GT 文件并按帧分类，筛除大目标\n#     \"\"\"\n#     gt = {}\n#     with open(filepath, 'r') as f:\n#         for line in f:\n#             parts = line.strip().split(',')\n#             try:\n#                 frame = int(float(parts[0]))\n#                 tid = int(float(parts[1]))\n#                 x, y, w, h = map(float, parts[2:6])\n#                 if w * h < AREA_THRESH:\n#                     if frame not in gt:\n#                         gt[frame] = []\n#                     gt[frame].append((tid, x, y, w, h))\n#             except:\n#                 continue\n#     return gt\n#\n#\n# def get_closest_target(boxes, center_x, direction):\n#     \"\"\"\n#     在指定方向中找出离中心最近的目标，返回 (tid, bx, by)\n#     \"\"\"\n#     best_box = None\n#     min_dist = float('inf')\n#     for tid, x, y, w, h in boxes:\n#         cx = x + w / 2\n#         by = y + h\n#         if (direction == 'left' and cx < center_x) or (direction == 'right' and cx > center_x):\n#             dist = abs(cx - center_x)\n#             if dist < min_dist:\n#                 min_dist = dist\n#                 best_box = (tid, cx, by)\n#     return best_box\n#\n#\n# def draw_matched_point(img, cx, cy, tid, pid, color=(0, 0, 255)):\n#     \"\"\"\n#     在图像上标注匹配点和目标 ID\n#     \"\"\"\n#     cv2.circle(img, (int(cx), int(cy)), 6, color, -1)\n#     cv2.putText(img, f'P{pid}-ID{tid}', (int(cx) + 5, int(cy) - 5),\n#                 cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)\n#\n#\n# def main():\n#     rgb_gt = load_gt_dict(rgb_gt_path)\n#     ir_gt = load_gt_dict(ir_gt_path)\n#     mask_flags = load_mask_flags(mask_flag_path)\n#\n#     matched_rgb = []\n#     matched_ir = []\n#\n#     frame_id = FRAME_START\n#     tries = 0\n#     point_idx = 1\n#\n#     with open(log_path, 'w') as log_f:\n#         log_f.write(\"Matched Points Log\\n====================\\n\")\n#\n#         while len(matched_rgb) < TARGET_MATCHED_POINTS and tries < NUM_TRIES:\n#             if frame_id in mask_flags:\n#                 print(f\"跳过被遮挡帧: {frame_id}\")\n#                 frame_id += FRAME_STEP\n#                 tries += 1\n#                 continue\n#\n#             rgb_objs = rgb_gt.get(frame_id, [])\n#             ir_objs = ir_gt.get(frame_id, [])\n#             if not rgb_objs or not ir_objs:\n#                 frame_id += FRAME_STEP\n#                 tries += 1\n#                 continue\n#\n#             rgb_img_path = rgb_img_template.format(frame_id)\n#             ir_img_path = ir_img_template.format(frame_id)\n#             rgb_img = cv2.imread(rgb_img_path)\n#             ir_img = cv2.imread(ir_img_path)\n#             if rgb_img is None or ir_img is None:\n#                 frame_id += FRAME_STEP\n#                 tries += 1\n#                 continue\n#\n#             rgb_center_x = rgb_img.shape[1] // 2\n#             ir_center_x = ir_img.shape[1] // 2\n#\n#             rgb_target = get_closest_target(rgb_objs, rgb_center_x, SEARCH_DIRECTION)\n#             ir_target = get_closest_target(ir_objs, ir_center_x, SEARCH_DIRECTION)\n#\n#             if rgb_target and ir_target:\n#                 tid_rgb, bx_rgb, by_rgb = rgb_target\n#                 tid_ir, bx_ir, by_ir = ir_target\n#                 matched_rgb.append((bx_rgb, by_rgb))\n#                 matched_ir.append((bx_ir, by_ir))\n#\n#                 log_f.write(f\"Matched Point P{point_idx}:\\n\")\n#                 log_f.write(f\"  Frame: {frame_id}\\n\")\n#                 log_f.write(f\"  RGB: id={tid_rgb}, (x={bx_rgb:.2f}, y={by_rgb:.2f})\\n\")\n#                 log_f.write(f\"  IR : id={tid_ir}, (x={bx_ir:.2f}, y={by_ir:.2f})\\n\\n\")\n#\n#                 draw_matched_point(rgb_img, bx_rgb, by_rgb, tid_rgb, point_idx, color=(0, 0, 255))\n#                 draw_matched_point(ir_img, bx_ir, by_ir, tid_ir, point_idx, color=(255, 0, 0))\n#                 #\n#                 # cv2.imwrite(f\"rgb_frame_{frame_id:06d}_matched.jpg\", rgb_img)\n#                 # cv2.imwrite(f\"ir_frame_{frame_id:06d}_matched.jpg\", ir_img)\n#\n#                 point_idx += 1\n#\n#             frame_id += FRAME_STEP\n#             tries += 1\n#\n#     if len(matched_rgb) < 3:\n#         print(f\"❌ 匹配点不足（{len(matched_rgb)}），无法生成单应性矩阵。\")\n#         return\n#\n#     rgb_pts = np.array(matched_rgb, dtype=np.float32).reshape(-1, 2)\n#     ir_pts = np.array(matched_ir, dtype=np.float32).reshape(-1, 2)\n#\n#     H, mask = cv2.findHomography(ir_pts, rgb_pts, method=cv2.RANSAC)\n#     if H is not None:\n#         np.save(save_path, H)\n#         print(f\"✅ 单应性矩阵保存成功: {save_path}\")\n#         print(f\"共使用匹配点: {len(rgb_pts)}\")\n#     else:\n#         print(\"❌ 单应性矩阵计算失败。\")\n#\n#\n# if __name__ == '__main__':\n#     main()\n\n\nimport os\nimport cv2\nimport numpy as np\n\n# ==== 可调参数 ====\nTARGET_MATCHED_POINTS = 200\nAREA_THRESH = 400000\nSEARCH_DIRECTION = 'left'  # 'left' or 'right'\n\n# ==== 文件路径 ====\nrgb_gt_path = r'D:\\JieRui2024\\datasets\\rgb_0275_gt.txt'\nir_gt_path = r'D:\\JieRui2024\\datasets\\inf_0275_gt.txt'\nmask_flag_path = r'D:\\JieRui2024\\datasets\\mask_0275gt.txt'\nsave_path = r'D:\\JieRui2024\\jierui24tools\\merge_INF2RGB_GT\\best_affine\\0275_affine_matrix.npy'\nlog_path = '0275_matched_points_log.txt'\n\n\ndef load_mask_flags(mask_path):\n    masked = set()\n    with open(mask_path, 'r') as f:\n        for line in f:\n            parts = line.strip().split(',')\n            if len(parts) >= 1:\n                frame_id = int(parts[0])\n                masked.add(frame_id)\n    return masked\n\n\ndef load_gt_dict(filepath):\n    gt = {}\n    with open(filepath, 'r') as f:\n        for line in f:\n            parts = line.strip().split(',')\n            try:\n                frame = int(float(parts[0]))\n                tid = int(float(parts[1]))\n                x, y, w, h = map(float, parts[2:6])\n                if w * h < AREA_THRESH:\n                    if frame not in gt:\n                        gt[frame] = []\n                    gt[frame].append((tid, x, y, w, h))\n            except:\n                continue\n    return gt\n\n\ndef get_closest_target(boxes, center_x, direction):\n    best_box = None\n    min_dist = float('inf')\n    for tid, x, y, w, h in boxes:\n        cx = x + w / 2\n        by = y + h\n        if (direction == 'left' and cx < center_x) or (direction == 'right' and cx > center_x):\n            dist = abs(cx - center_x)\n            if dist < min_dist:\n                min_dist = dist\n                best_box = (tid, cx, by)\n    return best_box\n\n\ndef main():\n    rgb_gt = load_gt_dict(rgb_gt_path)\n    ir_gt = load_gt_dict(ir_gt_path)\n    mask_flags = load_mask_flags(mask_flag_path)\n\n    matched_rgb = []\n    matched_ir = []\n    point_idx = 1\n\n    # 获取最大帧号\n    all_frame_ids = set()\n    with open(rgb_gt_path, 'r') as f:\n        for line in f:\n            parts = line.strip().split(',')\n            if len(parts) >= 1:\n                try:\n                    frame = int(float(parts[0]))\n                    all_frame_ids.add(frame)\n                except:\n                    continue\n    max_frame_id = max(all_frame_ids)\n    print(f\"\uD83D\uDCCC 从 RGB GT 中检测到最大帧号: {max_frame_id}\")\n\n    with open(log_path, 'w') as log_f:\n        log_f.write(\"Matched Points Log\\n====================\\n\")\n\n        for frame_id in range(1, max_frame_id + 1):\n            if len(matched_rgb) >= TARGET_MATCHED_POINTS:\n                break\n\n            if frame_id in mask_flags:\n                continue\n\n            rgb_objs = rgb_gt.get(frame_id, [])\n            ir_objs = ir_gt.get(frame_id, [])\n            if not rgb_objs or not ir_objs:\n                continue\n\n            # 直接使用图像中心点（假定图像宽度为1920）\n            center_x = 960\n\n            rgb_target = get_closest_target(rgb_objs, center_x, SEARCH_DIRECTION)\n            ir_target = get_closest_target(ir_objs, center_x, SEARCH_DIRECTION)\n\n            if rgb_target and ir_target:\n                tid_rgb, bx_rgb, by_rgb = rgb_target\n                tid_ir, bx_ir, by_ir = ir_target\n                matched_rgb.append((bx_rgb, by_rgb))\n                matched_ir.append((bx_ir, by_ir))\n\n                log_f.write(f\"Matched Point P{point_idx}:\\n\")\n                log_f.write(f\"  Frame: {frame_id}\\n\")\n                log_f.write(f\"  RGB: id={tid_rgb}, (x={bx_rgb:.2f}, y={by_rgb:.2f})\\n\")\n                log_f.write(f\"  IR : id={tid_ir}, (x={bx_ir:.2f}, y={by_ir:.2f})\\n\\n\")\n                point_idx += 1\n\n    if len(matched_rgb) < 3:\n        print(f\"❌ 匹配点不足（{len(matched_rgb)}），无法生成单应性矩阵。\")\n        return\n\n    rgb_pts = np.array(matched_rgb, dtype=np.float32).reshape(-1, 2)\n    ir_pts = np.array(matched_ir, dtype=np.float32).reshape(-1, 2)\n\n    H, mask = cv2.findHomography(ir_pts, rgb_pts, method=cv2.RANSAC)\n    if H is not None:\n        np.save(save_path, H)\n        print(f\"✅ 单应性矩阵保存成功: {save_path}\")\n        print(f\"共使用匹配点: {len(rgb_pts)}\")\n    else:\n        print(\"❌ 单应性矩阵计算失败。\")\n\n\nif __name__ == '__main__':\n    main()\n
===================================================================
diff --git a/ir2rgb_tools/new_align_ir2rgb.py b/ir2rgb_tools/new_align_ir2rgb.py
--- a/ir2rgb_tools/new_align_ir2rgb.py	(revision dbc911c9a2ae699fcbac2212b0393027753e4554)
+++ b/ir2rgb_tools/new_align_ir2rgb.py	(date 1749733228678)
@@ -180,11 +180,12 @@
 SEARCH_DIRECTION = 'left'  # 'left' or 'right'
 
 # ==== 文件路径 ====
-rgb_gt_path = r'D:\JieRui2024\datasets\rgb_0275_gt.txt'
-ir_gt_path = r'D:\JieRui2024\datasets\inf_0275_gt.txt'
-mask_flag_path = r'D:\JieRui2024\datasets\mask_0275gt.txt'
-save_path = r'D:\JieRui2024\jierui24tools\merge_INF2RGB_GT\best_affine\0275_affine_matrix.npy'
-log_path = '0275_matched_points_log.txt'
+rgb_gt_path = r'/Users/lisushang/Downloads/JieRui2024/datasets/rgb_0061_gt.txt'
+ir_gt_path = r'/Users/lisushang/Downloads/JieRui2024/datasets/inf_0061_gt.txt'
+mask_flag_path = r'/Users/lisushang/Downloads/JieRui2024/datasets/mask_0061gt.txt'
+# save_path = r'D:\JieRui2024\jierui24tools\merge_INF2RGB_GT\best_affine\0275_affine_matrix.npy'
+save_path = '../jierui24tools/merge_INF2RGB_GT/best_affine/0061_affine_matrix.npy'
+log_path = '0061_matched_points_log.txt'
 
 
 def load_mask_flags(mask_path):
Index: ir2rgb_tools/5-29-align.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n#     main()\nimport cv2\nimport numpy as np\nimport os\n\n# ==== 路径配置    ====\nrgb_gt_path = r'D:\\JieRui2024\\datasets\\rgb_0275_gt.txt'\nir_gt_path = r'D:\\JieRui2024\\datasets\\inf_0275_gt.txt'\nmask_flag_path = r'D:\\JieRui2024\\datasets\\mask_0275gt.txt'\nsave_path = '0275_affine_matrix.npy'\n\nrgb_img_template = r'D:\\5-16data\\jierui24_final_RGB\\train\\0275\\image\\{:06d}.jpg'\nir_img_template  = r'D:\\5-16data\\jierui24_final_INF\\train\\0275\\image\\{:06d}.jpg'\n\n# ==== 可调参数 ====\nAREA_THRESH = 40000\nNUM_FRAMES_LIMIT = 1000\nFRAME_START = 1\nVISUALIZE = False\nSHOW_IMAGE = False\n\n# ==== 获取最大帧号 ====\ndef get_max_frame(filepath):\n    max_frame = 0\n    with open(filepath, 'r') as f:\n        for line in f:\n            parts = line.strip().split(',')\n            try:\n                frame = int(float(parts[0]))\n                if frame > max_frame:\n                    max_frame = frame\n            except:\n                continue\n    return max_frame\n\n# ==== 载入遮挡帧标记 ====\ndef load_mask_flags(mask_path):\n    masked_frames = set()\n    with open(mask_path, 'r') as f:\n        for line in f:\n            parts = line.strip().split(',')\n            if int(parts[0]) == 1:\n                frame_id = int(parts[1])\n                masked_frames.add(frame_id)\n    return masked_frames\n\n# ==== 加载每帧的目标框 ====\ndef load_gt_dict_per_frame(filepath):\n    gt_per_frame = {}\n    with open(filepath, 'r') as f:\n        for line in f:\n            parts = line.strip().split(',')\n            try:\n                frame = int(float(parts[0]))\n                tid = int(float(parts[1]))\n                x, y, w, h = map(float, parts[2:6])\n                if frame not in gt_per_frame:\n                    gt_per_frame[frame] = {}\n                gt_per_frame[frame][tid] = (x, y, w, h)\n            except:\n                continue\n    return gt_per_frame\n\n# ==== 找到离图像中心最近的小目标 ====\ndef find_nearest_center_obj(gt_objs, image_center):\n    min_dist = float('inf')\n    best_pt = None\n    for (x, y, w, h) in gt_objs.values():\n        if w * h > AREA_THRESH:\n            continue\n        cx = x + w / 2\n        cy = y + h\n        dist = np.hypot(cx - image_center[0], cy - image_center[1])\n        if dist < min_dist:\n            min_dist = dist\n            best_pt = (cx, cy)\n    return best_pt\n\n# ==== 主函数 ====\ndef main():\n    max_frame = get_max_frame(rgb_gt_path)\n    rgb_gt = load_gt_dict_per_frame(rgb_gt_path)\n    ir_gt = load_gt_dict_per_frame(ir_gt_path)\n    masked_frames = load_mask_flags(mask_flag_path)\n\n    matched_rgb, matched_ir = [], []\n    frames_checked = 0\n    current_frame = FRAME_START\n\n    while current_frame <= max_frame and frames_checked < NUM_FRAMES_LIMIT:\n        if current_frame in masked_frames:\n            current_frame += 1\n            continue\n\n        rgb_objs = rgb_gt.get(current_frame, {})\n        ir_objs = ir_gt.get(current_frame, {})\n\n        rgb_img_path = rgb_img_template.format(current_frame)\n        ir_img_path = ir_img_template.format(current_frame)\n        rgb_img = cv2.imread(rgb_img_path)\n        ir_img = cv2.imread(ir_img_path)\n        if rgb_img is None or ir_img is None:\n            current_frame += 1\n            continue\n\n        rgb_center = (rgb_img.shape[1] // 2, rgb_img.shape[0] // 2)\n        ir_center = (ir_img.shape[1] // 2, ir_img.shape[0] // 2)\n\n        rgb_pt = find_nearest_center_obj(rgb_objs, rgb_center)\n        ir_pt = find_nearest_center_obj(ir_objs, ir_center)\n\n        if rgb_pt and ir_pt:\n            matched_rgb.append(rgb_pt)\n            matched_ir.append(ir_pt)\n            frames_checked += 1\n\n        current_frame += 1\n\n    if len(matched_rgb) < 3:\n        print(f\"⚠\uFE0F 匹配点不足（仅 {len(matched_rgb)} 对），无法估计单应性矩阵。\")\n        return\n\n    rgb_pts = np.array(matched_rgb, dtype=np.float32)\n    ir_pts = np.array(matched_ir, dtype=np.float32)\n    H, mask = cv2.findHomography(ir_pts, rgb_pts, method=cv2.RANSAC)\n\n    if H is not None:\n        np.save(save_path, H)\n        print(f\"✅ 单应性矩阵保存成功：{save_path}\")\n        print(f\"共使用匹配点数：{len(rgb_pts)}\")\n    else:\n        print(\"❌ 单应性矩阵估计失败。\")\n\nif __name__ == '__main__':\n    main()\n
===================================================================
diff --git a/ir2rgb_tools/5-29-align.py b/ir2rgb_tools/5-29-align.py
--- a/ir2rgb_tools/5-29-align.py	(revision dbc911c9a2ae699fcbac2212b0393027753e4554)
+++ b/ir2rgb_tools/5-29-align.py	(date 1749731893987)
@@ -5,13 +5,14 @@
 import os
 
 # ==== 路径配置    ====
-rgb_gt_path = r'D:\JieRui2024\datasets\rgb_0275_gt.txt'
-ir_gt_path = r'D:\JieRui2024\datasets\inf_0275_gt.txt'
-mask_flag_path = r'D:\JieRui2024\datasets\mask_0275gt.txt'
-save_path = '0275_affine_matrix.npy'
+rgb_gt_path = r'/Users/lisushang/Downloads/JieRui2024/datasets/rgb_0190_gt.txt'
+ir_gt_path = r'/Users/lisushang/Downloads/JieRui2024/datasets/inf_0190_gt.txt'
+mask_flag_path = r'/Users/lisushang/Downloads/JieRui2024/datasets/mask_0190gt.txt'
+save_path = '0190_affine_matrix.npy'
 
-rgb_img_template = r'D:\5-16data\jierui24_final_RGB\train\0275\image\{:06d}.jpg'
-ir_img_template  = r'D:\5-16data\jierui24_final_INF\train\0275\image\{:06d}.jpg'
+# 图像路径模板
+rgb_img_template = r'/Users/lisushang/Downloads/jierui24_final_RGB/train/0190/image/{:06d}.jpg'
+ir_img_template = r'/Users/lisushang/Downloads/jierui24_final_INF/train/0190/image/{:06d}.jpg'
 
 # ==== 可调参数 ====
 AREA_THRESH = 40000
Index: ir2rgb_tools/auto_align_ir2rgb.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># import cv2\n# import numpy as np\n# import os\n# from collections import defaultdict\n#\n# # 用户配置路径\n# rgb_gt_path = r'D:\\JieRui2024\\datasets\\0061gt.txt'\n# ir_gt_path = r'D:\\JieRui2024\\datasets\\0061gt_mask.txt'\n# save_path = '0061_ir_to_rgb_h.npy'\n# frame_id = 1  # 默认使用第一帧配对\n#\n# # 解析 GT 文件\n# def load_mot_gt(filepath, target_frame):\n#     boxes = defaultdict(tuple)\n#     with open(filepath, 'r') as f:\n#         for line in f:\n#             parts = line.strip().split(',')\n#             try:\n#                 frame = int(float(parts[0]))  # 支持 '1.0' 或 '1'\n#                 if frame != target_frame:\n#                     continue\n#                 tid = int(float(parts[1]))\n#                 x, y, w, h = map(float, parts[2:6])\n#                 cx = x + w / 2\n#                 cy = y + h / 2\n#                 boxes[tid] = (cx, cy)\n#             except ValueError as e:\n#                 print(f\"跳过无法解析的行: {line.strip()} 错误: {e}\")\n#     return boxes\n#\n# # 匹配 RGB/IR 中相同 ID 的目标\n# def match_targets(rgb_dict, ir_dict):\n#     matched_rgb = []\n#     matched_ir = []\n#     for tid in rgb_dict:\n#         if tid in ir_dict:\n#             matched_rgb.append(rgb_dict[tid])\n#             matched_ir.append(ir_dict[tid])\n#     return matched_rgb, matched_ir\n#\n# # 主流程\n# def main():\n#     rgb_centers = load_mot_gt(rgb_gt_path, frame_id)\n#     ir_centers = load_mot_gt(ir_gt_path, frame_id)\n#\n#     print(f\"RGB IDs: {list(rgb_centers.keys())}\")\n#     print(f\" IR IDs: {list(ir_centers.keys())}\")\n#\n#     rgb_pts, ir_pts = match_targets(rgb_centers, ir_centers)\n#\n#     if len(rgb_pts) < 3:\n#         print(\"匹配点数不足，无法估算单应性矩阵（需要至少3对）。\")\n#         return\n#\n#     rgb_pts_np = np.array(rgb_pts, dtype=np.float32)\n#     ir_pts_np = np.array(ir_pts, dtype=np.float32)\n#\n#     H, mask = cv2.findHomography(ir_pts_np, rgb_pts_np, method=cv2.RANSAC)\n#     if H is not None:\n#         np.save(save_path, H)\n#         print(f\"成功保存单应性矩阵到：{save_path}\")\n#         print(f\"共匹配 ID 数：{len(rgb_pts)}\")\n#     else:\n#         print(\"计算单应性矩阵失败。\")\n#\n# if __name__ == '__main__':\n#     main()\nimport cv2\nimport numpy as np\nimport os\n\n# ==== 可调参数 ====\nNUM_FRAMES = 5\nAREA_THRESH = 4000\nMAX_MATCHED_POINTS = 10\nFRAME_START = 1\nVISUALIZE = True  # 是否保存每帧可视化图像\nSHOW_IMAGE = False  # 是否用cv2.imshow显示每帧（调试时可以用）\n\n# ==== 文件路径 ====\nrgb_gt_path = r'D:\\JieRui2024\\datasets\\rgb_0275_gt.txt'\nir_gt_path = r'D:\\JieRui2024\\datasets\\inf_0275_gt.txt'\nmask_flag_path = r'D:\\JieRui2024\\datasets\\mask_0275gt.txt'\nsave_path = '0275_ir_to_rgb_h.npy'\n\n# 图像路径模板\nrgb_img_template = r'D:\\5-16data\\jierui24_final_RGB\\train\\0275\\image\\{:06d}.jpg'\nir_img_template = r'D:\\5-16data\\jierui24_final_RGB\\train\\0275\\image\\{:06d}.jpg'\ndef load_mask_flags(mask_path):\n    masked_frames = set()\n    with open(mask_path, 'r') as f:\n        for line in f:\n            parts = line.strip().split(',')\n            if int(parts[0]) == 1:\n                frame_id = int(parts[1])\n                masked_frames.add(frame_id)\n    return masked_frames\n\n\ndef load_gt_dict_per_frame(filepath):\n    gt_per_frame = {}\n    with open(filepath, 'r') as f:\n        for line in f:\n            parts = line.strip().split(',')\n            try:\n                frame = int(float(parts[0]))\n                tid = int(float(parts[1]))\n                x, y, w, h = map(float, parts[2:6])\n                if frame not in gt_per_frame:\n                    gt_per_frame[frame] = {}\n                gt_per_frame[frame][tid] = (x, y, w, h)\n            except:\n                continue\n    return gt_per_frame\n\n\ndef draw_boxes_and_matches(img, all_boxes, matched_pts_dict, frame_id):\n    for tid, (x, y, w, h) in all_boxes.items():\n        color = (0, 255, 0)\n        if tid in matched_pts_dict:\n            color = (0, 0, 255)\n        cv2.rectangle(img, (int(x), int(y)), (int(x + w), int(y + h)), color, 2)\n        if tid in matched_pts_dict:\n            cx, cy = matched_pts_dict[tid]\n            cv2.circle(img, (int(cx), int(cy)), 5, color, -1)\n            cv2.putText(img, f'{tid}', (int(cx + 5), int(cy - 5)), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)\n    cv2.putText(img, f'Frame {frame_id}', (20, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)\n    return img\n\n\ndef main():\n    rgb_gt = load_gt_dict_per_frame(rgb_gt_path)\n    ir_gt = load_gt_dict_per_frame(ir_gt_path)\n    masked_frames = load_mask_flags(mask_flag_path)\n\n    matched_rgb = []\n    matched_ir = []\n    frames_checked = 0\n    current_frame = FRAME_START\n\n    while frames_checked < NUM_FRAMES:\n        if current_frame in masked_frames:\n            current_frame += 1\n            continue\n\n        rgb_objs = rgb_gt.get(current_frame, {})\n        ir_objs = ir_gt.get(current_frame, {})\n\n        frame_matched_rgb = {}\n        frame_matched_ir = {}\n\n        for tid, (x, y, w, h) in rgb_objs.items():\n            area = w * h\n            if tid in ir_objs and area < AREA_THRESH:\n                # 计算底部中心点\n                bx_rgb = x + w / 2\n                by_rgb = y + h\n                x2, y2, w2, h2 = ir_objs[tid]\n                bx_ir = x2 + w2 / 2\n                by_ir = y2 + h2\n\n                matched_rgb.append((bx_rgb, by_rgb))\n                matched_ir.append((bx_ir, by_ir))\n                frame_matched_rgb[tid] = (bx_rgb, by_rgb)\n                frame_matched_ir[tid] = (bx_ir, by_ir)\n\n                if len(matched_rgb) >= MAX_MATCHED_POINTS:\n                    break\n\n        # 可视化\n        if VISUALIZE:\n            rgb_img_path = rgb_img_template.format(current_frame)\n            rgb_img = cv2.imread(rgb_img_path)\n            if rgb_img is not None:\n                vis = draw_boxes_and_matches(rgb_img.copy(), rgb_objs, frame_matched_rgb, current_frame)\n                vis_save_path = f'vis_frame_{current_frame:04d}.jpg'\n                cv2.imwrite(vis_save_path, vis)\n                if SHOW_IMAGE:\n                    cv2.imshow('vis', vis)\n                    cv2.waitKey(500)\n\n        if len(matched_rgb) >= MAX_MATCHED_POINTS:\n            break\n\n        frames_checked += 1\n        current_frame += 1\n\n    if SHOW_IMAGE:\n        cv2.destroyAllWindows()\n\n    if len(matched_rgb) < 3:\n        print(f\"有效匹配点不足（仅找到 {len(matched_rgb)} 对），无法生成单应性矩阵。\")\n        return\n\n    rgb_pts = np.array(matched_rgb, dtype=np.float32).reshape(-1, 2)\n    ir_pts = np.array(matched_ir, dtype=np.float32).reshape(-1, 2)\n\n    H, mask = cv2.findHomography(ir_pts, rgb_pts, method=cv2.RANSAC)\n    if H is not None:\n        np.save(save_path, H)\n        print(f\"单应性矩阵保存成功：{save_path}\")\n        print(f\"共使用 {len(rgb_pts)} 对匹配点\")\n    else:\n        print(\"单应性矩阵估计失败。\")\n\n\nif __name__ == '__main__':\n    main()
===================================================================
diff --git a/ir2rgb_tools/auto_align_ir2rgb.py b/ir2rgb_tools/auto_align_ir2rgb.py
--- a/ir2rgb_tools/auto_align_ir2rgb.py	(revision dbc911c9a2ae699fcbac2212b0393027753e4554)
+++ b/ir2rgb_tools/auto_align_ir2rgb.py	(date 1749732338284)
@@ -78,14 +78,14 @@
 SHOW_IMAGE = False  # 是否用cv2.imshow显示每帧（调试时可以用）
 
 # ==== 文件路径 ====
-rgb_gt_path = r'D:\JieRui2024\datasets\rgb_0275_gt.txt'
-ir_gt_path = r'D:\JieRui2024\datasets\inf_0275_gt.txt'
-mask_flag_path = r'D:\JieRui2024\datasets\mask_0275gt.txt'
-save_path = '0275_ir_to_rgb_h.npy'
+rgb_gt_path = r'/Users/lisushang/Downloads/JieRui2024/datasets/rgb_0061_gt.txt'
+ir_gt_path = r'/Users/lisushang/Downloads/JieRui2024/datasets/inf_0061_gt.txt'
+mask_flag_path = r'/Users/lisushang/Downloads/JieRui2024/datasets/mask_0061gt.txt'
+save_path = '0061_ir_to_rgb_h.npy'
 
 # 图像路径模板
-rgb_img_template = r'D:\5-16data\jierui24_final_RGB\train\0275\image\{:06d}.jpg'
-ir_img_template = r'D:\5-16data\jierui24_final_RGB\train\0275\image\{:06d}.jpg'
+rgb_img_template = r'/Users/lisushang/Downloads/jierui24_final_RGB/train/0061/image/{:06d}.jpg'
+ir_img_template = r'/Users/lisushang/Downloads/jierui24_final_INF/train/0061/image/{:06d}.jpg'
 def load_mask_flags(mask_path):
     masked_frames = set()
     with open(mask_path, 'r') as f:
